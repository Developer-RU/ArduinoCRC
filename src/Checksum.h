/**
 * @file Checksum.h
 * @brief Заголовочный файл класса для вычисления 8-битной контрольной суммы
 * @author WASH-PRO
 * @email p.masyukov@gmail.com
 * 
 * Класс предоставляет функционал для инкрементального вычисления 
 * контрольной суммы как простой суммы байтов (с накоплением в uint8_t).
 * 
 * @note Использует начальное значение 0xFF для контрольной суммы
 * @warning Из-за использования 8-битного переполнения контрольная сумма 
 *          не является криптографически стойкой и предназначена только 
 *          для проверки целостности данных
 */

#pragma once

#include <stdint.h>
#include <stddef.h>

namespace utils {

/**
 * @class Checksum
 * @brief Класс для вычисления и проверки 8-битной контрольной суммы
 * 
 * Поддерживает два режима работы:
 * 1. Инкрементальный - последовательное добавление данных
 * 2. Пакетный - вычисление за один вызов
 */
class Checksum {
public:
    // ==================== Методы инкрементального вычисления ====================
    
    /**
     * @brief Сбрасывает контрольную сумму до начального значения
     * @note Метод start() используется вместо reset() для совместимости со старым кодом
     */
    void start();
    
    /**
     * @brief Добавляет один байт к текущей контрольной сумме
     * @param byte Байт данных для добавления
     */
    void add(uint8_t byte);
    
    /**
     * @brief Добавляет массив байтов к текущей контрольной сумме
     * @param data Указатель на массив данных
     * @param dataLen Количество байтов для добавления
     */
    void add(const uint8_t* data, uint16_t dataLen);
    
    /**
     * @brief Возвращает текущее значение контрольной суммы
     * @return Вычисленная контрольная сумма (0-255)
     */
    uint8_t get() const;
    
    // ==================== Статические методы пакетного вычисления ====================
    
    /**
     * @brief Вычисляет контрольную сумму для заданного массива данных
     * @param data Указатель на массив данных
     * @param dataLen Количество байтов для обработки
     * @return Контрольная сумма для переданных данных
     * 
     * @note Удобный метод для разового вычисления без создания объекта
     */
    static uint8_t calculate(const uint8_t* data, uint16_t dataLen);
    
    /**
     * @brief Проверяет корректность контрольной суммы для данных
     * @param data Указатель на массив данных
     * @param dataLen Количество байтов для обработки
     * @param expected Ожидаемое значение контрольной суммы
     * @return true если вычисленная контрольная сумма совпадает с ожидаемой
     */
    static bool verify(const uint8_t* data, uint16_t dataLen, uint8_t expected);

private:
    static const uint8_t INITIAL_VALUE = 0xFF;  ///< Начальное значение контрольной суммы
    uint8_t m_checksum;                         ///< Текущее значение контрольной суммы
};

} // namespace utils
